---
layout: post
title: "Access logs in Play! using RequestHeader tags"
date: 2013-07-14 13:30
comments: true
categories: [Play, Scala]
---
Log files as event streams
--------------------------

Having long been a fan of treating [log files as streams of events](http://12factor.net/logs) (JSON formatted), I thought it would be useful to share a little bit of code to demonstrate how to achieve access style logging in a Play application. There's certainly more than one solution to this problem (there is, for example, a nice little plugin here:Â [https://github.com/briannesbitt/play-accesslog](https://github.com/briannesbitt/play-accesslog)), but I wanted to share something that I 'discovered' in Play that, whilst not clearly documented - I found it by digging through the source - is particularly handy for this use case.

Just after starting this post, I noticed another great [article](http://matthiasnehlsen.com/blog/2013/07/09/transforming-logs-into-information/) from [@matthiasnehlsen](https://twitter.com/matthiasnehlsen) about using [Kibana](http://kibana.org/) to store log events generated in Play applications. Kibana is a great tool - backed by the awesome Elasticsearch - and I also highly recommend it. I won't go into any detail in this article about sending logs to Kibana as Matthias has done a great job of doing that :-) Suffice to say, though, the information in my article here would certainly play nicely with Kibana - I simply want to make you aware of how you can extract some useful information from Play to enhance your log events no matter where you might wish to send them (log files included!).

RequestHeader tags
------------------

So...back to this feature I discovered - `RequestHeader` tags! It turns out that Play associates some very useful 'tags' along with the `RequestHeader` generated for each request. You can get hold of this `Map` of tags by calling `RequestHeader.tags`.

Given this learning, we can build a Play `EssentialFilter` - that will wrap every request - and log the JSON formatted request information to the Play `Logger`.

{% codeblock lang:scala %}
object AccessLogFilter extends EssentialFilter {

  val dateTimeFormat = ISODateTimeFormat.ordinalDateTimeNoMillis()

  def apply(next: EssentialAction) = new EssentialAction {
    def apply(rh: RequestHeader) = {
      val startTime = System.currentTimeMillis()

      def logTime(result: PlainResult): Result = {
        val event = Json.obj(
          "uri" -> rh.uri,
          "timestamp" -> dateTimeFormat.print(new DateTime),
          "execution_time" -> (System.currentTimeMillis() - startTime),
          "status" -> result.header.status,
          "tags" -> Json.toJson(rh.tags.map(entry => entry._1.toLowerCase -> entry._2))
        )
        Logger.info(Json.stringify(event))
        result
      }

      next(rh).map {
        case plain: PlainResult => logTime(plain)
        case async: AsyncResult => async.transform(logTime)
      }
    }
  }
}
{% endcodeblock %}

On top of adding the tags (and some other available request info) to the JSON object, you'll see the execution time is also captured alongside. To enable this filter, we simply create a custom `Global.scala`, in the default package:

{% codeblock lang:scala %}
object Global extends WithFilters(AccessLogFilter) {
}
{% endcodeblock %}

Here is an example log line generated by this filter (prettified for readability):

{% codeblock lang:json %}
{
   "uri":"/search/*",
   "timestamp":"2013-194T18:14:27+01:00",
   "execution_time":20,
   "status":200,
   "tags":{
      "route_verb":"GET",
      "route_action_method":"search",
      "route_pattern":"/search/$searchString",
      "route_controller":"controllers.Application",
      "route_comments":"Root action"
   }
}
{% endcodeblock %}

One of the most useful things about capturing the tags is that you get easy access to 'normalized' actions/endpoints. So, it's immediately easy (e.g. in a tool like Kibana) to pick all log events related to a specific action. The URI alone is not good enough because parameterized path variables, or query string parameters, lead to non-unique URI representations for the same logical action bindings.

As the filter wraps every request, you will see log lines generated for static assets too - something that is most likely too verbose for most use cases. It's not too hard to apply filtering to the URI extension to ignore assets, but I left it out of the example code for the sake of cleanliness.

Keep on logging!